<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Neon Snake · 联机版</title>
  <meta name="theme-color" content="#070a14" />
  <style>
    :root{
      --bg:#070a14;
      --panel:#0f1633;
      --text:#eaf0ff;
      --muted:#9aa6d6;
      --grid:#1a2450;
      --grid2:#22306b;
      --shadow: 0 24px 70px rgba(0,0,0,.45);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Noto Sans CJK SC", "Microsoft YaHei", Arial, sans-serif;
      background:
        radial-gradient(900px 600px at 15% 10%, rgba(74,222,128,.16), transparent 60%),
        radial-gradient(1000px 700px at 85% 20%, rgba(251,113,133,.12), transparent 55%),
        radial-gradient(1200px 900px at 30% 95%, rgba(99,102,241,.10), transparent 60%),
        linear-gradient(180deg, #070a14 0%, #060812 100%);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding: clamp(10px, 2vw, 18px);
      padding-bottom: max(12px, env(safe-area-inset-bottom));
      overflow-x:hidden;
    }
    .wrap{ width:min(1100px, 100%); display:grid; gap:12px; }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid color-mix(in oklab, var(--grid2) 70%, white 30%);
      border-radius:18px;
      overflow:hidden;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    header{
      padding:14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      border-bottom:1px solid rgba(34,48,107,.65);
      background: linear-gradient(180deg, rgba(15,22,51,.85), rgba(11,16,32,.55));
    }
    header h1{ font-size:15px; margin:0; letter-spacing:.5px; }
    .stats{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:13px; color:var(--muted); }
    .pill{ padding:6px 10px; border-radius:999px; border:1px solid rgba(34,48,107,.75); background: rgba(255,255,255,.04); color:var(--text); font-variant-numeric: tabular-nums; white-space:nowrap; }

    .row{ padding:12px; display:grid; gap:12px; grid-template-columns: 1fr 360px; align-items:start; }

    #gameContainer{
      width:100%;
      height: min(72vh, 680px);
      border-radius:14px;
      border:1px solid rgba(34,48,107,.75);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      overflow:hidden;
      position:relative;
      touch-action:none;
    }

    .panel{ display:grid; gap:10px; padding:12px; border:1px solid rgba(34,48,107,.65); border-radius:14px; background: rgba(0,0,0,.20); }
    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    label{ font-size:12px; color:var(--muted); display:grid; gap:6px; }
    input, select, button{
      border:1px solid rgba(34,48,107,.85);
      background: rgba(255,255,255,.05);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-size:13px;
    }
    button{ cursor:pointer; }
    button:hover{ background: rgba(255,255,255,.08); }
    button.primary{ border-color: rgba(34,197,94,.45); background: linear-gradient(180deg, rgba(34,197,94,.22), rgba(34,197,94,.10)); }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .actions{ display:flex; gap:10px; flex-wrap:wrap; }
    .hint{ font-size:12px; color:var(--muted); line-height:1.6; }

    .players{ display:grid; gap:6px; }
    .p{ display:flex; justify-content:space-between; align-items:center; gap:10px; padding:8px 10px; border:1px solid rgba(34,48,107,.55); border-radius:12px; background: rgba(255,255,255,.03); font-variant-numeric: tabular-nums; }
    .left{ display:flex; align-items:center; gap:8px; }
    .dot{ width:10px; height:10px; border-radius:999px; background: #4ade80; }
    .small{ color:var(--muted); font-size:12px; }

    .overlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
    }
    .modal{
      width:min(560px, 92vw);
      border-radius:16px;
      border:1px solid rgba(34,48,107,.65);
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      padding:14px;
      box-shadow: 0 24px 70px rgba(0,0,0,.55);
    }

    .toast{ position:fixed; left:50%; top:16px; transform:translateX(-50%); background: rgba(0,0,0,.62); border:1px solid rgba(255,255,255,.12); color:var(--text); padding:10px 12px; border-radius:14px; font-size:13px; display:none; backdrop-filter: blur(10px); max-width:min(640px, 92vw); text-align:center; z-index:10; }
    .toast.show{ display:block; }

    @media (max-width: 980px){
      .row{ grid-template-columns: 1fr 320px; }
    }

    @media (max-width: 820px){
      .row{ grid-template-columns: 1fr; }
      #gameContainer{ height: min(52vh, 520px); }
      .grid{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1>Neon Snake</h1>
        <div class="stats">
          <div class="pill">模式：<span id="mode">—</span></div>
          <div class="pill">房间：<span id="roomCode">—</span></div>
          <div class="pill">时间：<span id="timeLeft">—</span></div>
          <div class="pill">状态：<span id="status">未连接</span></div>
          <div class="pill">延迟：<span id="latency">—</span></div>
          <div class="pill">Tick：<span id="tickHz">—</span></div>
        </div>
      </header>

      <div class="row">
        <div id="gameContainer" aria-label="Game">
          <div id="modeOverlay" class="overlay" style="display:none;">
            <div class="modal">
              <div style="font-weight:900; font-size:18px; letter-spacing:.4px;">选择模式</div>
              <div style="margin-top:8px; color:rgba(154,166,214,.95); font-size:12px; line-height:1.6;">
                单机适合练手；联机支持 2~4 人同局。联机需要网络，延迟高会影响手感。
              </div>
              <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;">
                <button id="btnModeSingle" style="flex:1 1 180px;" class="primary">单机模式</button>
                <button id="btnModeMulti" style="flex:1 1 180px;">联机模式</button>
              </div>
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="grid">
            <label>昵称
              <input id="name" placeholder="比如：小明" maxlength="16" />
            </label>
            <label>颜色
              <select id="color">
                <option value="green">绿色</option>
                <option value="blue">蓝色</option>
                <option value="purple">紫色</option>
                <option value="orange">橙色</option>
                <option value="pink">粉色</option>
              </select>
            </label>
            <label>房间码（加入用）
              <input id="code" placeholder="例如 ABCD1" maxlength="5" />
            </label>
            <label>
              <div class="actions">
                <button class="primary" id="btnCreate">创建房间</button>
                <button id="btnJoin">加入房间</button>
                <button id="btnStart">开始 2 分钟</button>
              </div>
            </label>
          </div>

          <div class="players" id="players"></div>

          <div class="hint">
            电脑：方向键 / WASD。手机：在棋盘上滑动。
            <br/>说明：联机版“权威判定在服务器”，所以会受网络延迟影响；我会继续做客户端预测来接近本地手感。
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Phaser 3 (local) -->
  <script src="/vendor/phaser.min.js"></script>

<script>
(() => {
  const GRID = 20;
  const LOGICAL_SIZE = 640; // fixed internal resolution, scaled by CSS
  const CELL = LOGICAL_SIZE / GRID;
  const TICK_MS_FALLBACK = 50;

  const SINGLE_URL = 'https://yjl1106-ops.github.io/snake/';

  const elMode = document.getElementById('mode');
  const elRoomCode = document.getElementById('roomCode');
  const elTimeLeft = document.getElementById('timeLeft');
  const elStatus = document.getElementById('status');
  const elLatency = document.getElementById('latency');
  const elTickHz = document.getElementById('tickHz');

  const elPlayers = document.getElementById('players');
  const toast = document.getElementById('toast');

  const inpName = document.getElementById('name');
  const inpColor = document.getElementById('color');
  const inpCode = document.getElementById('code');

  const btnCreate = document.getElementById('btnCreate');
  const btnJoin = document.getElementById('btnJoin');
  const btnStart = document.getElementById('btnStart');

  const modeOverlay = document.getElementById('modeOverlay');
  const btnModeSingle = document.getElementById('btnModeSingle');
  const btnModeMulti = document.getElementById('btnModeMulti');

  const container = document.getElementById('gameContainer');

  const themes = {
    green:  {a:0x4ade80, b:0x22c55e},
    blue:   {a:0x60a5fa, b:0x3b82f6},
    purple: {a:0xa78bfa, b:0x8b5cf6},
    orange: {a:0xfb923c, b:0xf97316},
    pink:   {a:0xfb7185, b:0xf43f5e},
  };

  function showToast(msg, ms=1200){
    toast.textContent = msg;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toast.classList.remove('show'), ms);
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function fmtMs(ms){
    const s = Math.ceil(ms/1000);
    const m = Math.floor(s/60);
    const r = s%60;
    return `${m}:${String(r).padStart(2,'0')}`;
  }

  // ===== Mode picker =====
  const qs = new URLSearchParams(location.search);
  const selectedMode = (qs.get('mode') || '').toLowerCase();
  function chooseMulti(){
    modeOverlay.style.display = 'none';
    elMode.textContent = '联机';
  }
  function showMode(){
    modeOverlay.style.display = 'flex';
    elMode.textContent = '未选择';
  }
  if (selectedMode === 'single') {
    location.replace(SINGLE_URL);
  } else if (selectedMode === 'multi') {
    chooseMulti();
  } else {
    showMode();
  }
  btnModeSingle.addEventListener('click', () => { location.href = SINGLE_URL; });
  btnModeMulti.addEventListener('click', () => {
    const u = new URL(location.href);
    u.searchParams.set('mode','multi');
    history.replaceState(null,'',u.toString());
    chooseMulti();
  });

  // ===== Phaser =====
  class MainScene extends Phaser.Scene {
    constructor(){ super('main'); }

    create(){
      this.cameras.main.setBackgroundColor(0x060812);
      this.cameras.main.setRoundPixels(true);

      this.gridG = this.add.graphics();
      this.dynG = this.add.graphics();
      this.uiG = this.add.graphics();

      this.drawGrid();

      // touch swipe
      this._touchStart = null;
      this.input.on('pointerdown', (p) => { this._touchStart = {x:p.x, y:p.y, t:performance.now()}; });
      this.input.on('pointerup', (p) => {
        if (!this._touchStart) return;
        const dx = p.x - this._touchStart.x;
        const dy = p.y - this._touchStart.y;
        const adx = Math.abs(dx), ady = Math.abs(dy);
        const dt = performance.now() - this._touchStart.t;
        this._touchStart = null;

        if (adx < 10 && ady < 10 && dt < 250) return;
        if (Math.max(adx, ady) < 22) return;
        if (adx > ady) setDir(dx > 0 ? 1 : -1, 0);
        else setDir(0, dy > 0 ? 1 : -1);
      });
    }

    drawGrid(){
      this.gridG.clear();
      for (let y=0;y<GRID;y++){
        for (let x=0;x<GRID;x++){
          const px = x*CELL;
          const py = y*CELL;
          const major = (x%5===0) || (y%5===0);
          const line = major ? 0x22306b : 0x1a2450;
          const a = major ? 0.26 : 0.14;
          this.gridG.lineStyle(1, line, a);
          this.gridG.strokeRect(px, py, CELL, CELL);
        }
      }
    }

    renderState(tick, predict){
      this.dynG.clear();
      this.uiG.clear();

      if (!tick) {
        this.uiG.fillStyle(0x000000, 0.35);
        this.uiG.fillRect(0,0,LOGICAL_SIZE,LOGICAL_SIZE);
        return;
      }

      // Smooth phase inside current cell step (reduces "晃/抖" when packets are uneven).
      // For self: use prediction accumulator; for others: approximate from time since last packet.
      // phase: 0..1 progress toward the next cell
      const selfPhase = predict?.enabled ? Math.max(0, Math.min(1, (predict.accMs / Math.max(1, predict.tickMs)))) : 0;
      const otherPhase = Math.max(0, Math.min(1, (performance.now() - net.lastRecvAt) / Math.max(1, predict.tickMs)));

      // food
      if (tick.food){
        this.drawCell(tick.food.x, tick.food.y, 0xfb7185, 1.0, true);
      }

      // snakes (use predicted for self)
      for (const p of tick.players){
        const th = themes[p.color] || themes.green;
        const isSelf = (predict?.enabled && p.id === window.__YOU_ID);

        let snake = p.snake;
        const dir = p.dir || {x:0,y:0};

        // For self we already render a fully predicted snake (with immediate turns).
        // Do NOT apply extra interpolation offset to self; it can cause "turn then snap back".
        const phase = isSelf ? 0 : otherPhase;
        const drawDir = isSelf ? (predict.dir || dir) : dir;

        if (isSelf && predict.snake) snake = predict.snake;
        if (!snake || !snake.length) continue;

        for (let i=0;i<snake.length;i++){
          const c = (i === snake.length-1) ? th.b : th.a;
          this.drawCell(snake[i].x + drawDir.x*phase, snake[i].y + drawDir.y*phase, c, 1.0, false);
        }
      }
    }

    drawCell(gx, gy, color, alpha=1, glow=false){
      const px = gx*CELL;
      const py = gy*CELL;
      const inset = glow ? 4 : 5;
      const w = CELL - inset*2;
      const h = CELL - inset*2;
      if (glow){
        this.dynG.fillStyle(color, 0.18);
        this.dynG.fillRoundedRect(px+2, py+2, CELL-4, CELL-4, 8);
      }
      this.dynG.fillStyle(color, alpha);
      this.dynG.fillRoundedRect(px+inset, py+inset, w, h, 8);
      this.dynG.fillStyle(0x000000, 0.12);
      this.dynG.fillRoundedRect(px+inset+1, py+inset+1, w-2, h-2, 7);
    }
  }

  const config = {
    type: Phaser.CANVAS,
    parent: container,
    width: LOGICAL_SIZE,
    height: LOGICAL_SIZE,
    backgroundColor: '#060812',
    pixelArt: true,
    antialias: false,
    scene: [MainScene],
    fps: { target: 60, forceSetTimeOut: true },
    scale: {
      mode: Phaser.Scale.FIT,
      autoCenter: Phaser.Scale.CENTER_BOTH,
      width: LOGICAL_SIZE,
      height: LOGICAL_SIZE,
    }
  };

  const game = new Phaser.Game(config);

  function scene(){ return game.scene.getScene('main'); }
  // expose for Scene render override
  window.__YOU_ID = null;

  // ===== Network =====
  const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host;
  const ws = new WebSocket(wsUrl);

  const net = {
    youId: null,
    room: null,
    tick: null,
    prevTick: null,
    tickHz: null,
    lastRecvAt: 0,
    rttMs: null,
    _pingT: 0,
  };

  // Client-side prediction (local feel)
  const predict = {
    enabled: true,
    tickHz: 20,
    tickMs: TICK_MS_FALLBACK, // step duration (ms) based on cps
    dir: {x: 1, y: 0},
    snake: null,
    food: null,

    // RAF-based accumulator (less jitter than setInterval)
    rafId: null,
    accMs: 0,
    lastNow: performance.now(),
  };

  function wsReady(){ return ws.readyState === WebSocket.OPEN; }
  function send(obj){
    if (!wsReady()) { showToast('网络未连接，稍等…'); return; }
    ws.send(JSON.stringify(obj));
  }

  // Ping/Pong RTT (so "延迟"不会一直显示 0)
  function sendPing(){
    if (!wsReady()) return;
    const t = performance.now();
    net._pingT = t;
    ws.send(JSON.stringify({ t:'ping', ts: t }));
  }
  setInterval(sendPing, 1000);

  // disable buttons until open
  btnCreate.disabled = true;
  btnJoin.disabled = true;
  btnStart.disabled = true;

  ws.addEventListener('open', () => {
    elStatus.textContent = '已连接';
    btnCreate.disabled = false;
    btnJoin.disabled = false;
    btnStart.disabled = false;
  });
  ws.addEventListener('close', () => {
    elStatus.textContent = '已断开';
    btnCreate.disabled = true;
    btnJoin.disabled = true;
    btnStart.disabled = true;
  });

  ws.addEventListener('message', (ev) => {
    const msg = JSON.parse(ev.data);
    net.lastRecvAt = performance.now();

    if (msg.t === 'hello') {
      net.youId = msg.id;
      window.__YOU_ID = msg.id;
      net.tickHz = msg.tickHz;
      predict.tickHz = msg.tickHz || 20;
      predict.tickMs = 1000 / (msg.cps || 7.5);
      elTickHz.textContent = String(msg.tickHz);
      return;
    }
    if (msg.t === 'error') {
      showToast(msg.message || '出错');
      return;
    }
    if (msg.t === 'joined' || msg.t === 'players' || msg.t === 'room' || msg.t === 'ended') {
      net.room = msg.room;
      renderRoom();
      return;
    }
    if (msg.t === 'pong') {
      // RTT in ms
      if (typeof msg.ts === 'number') {
        const rtt = performance.now() - msg.ts;
        if (isFinite(rtt) && rtt >= 0) net.rttMs = rtt;
      } else if (net._pingT) {
        const rtt = performance.now() - net._pingT;
        if (isFinite(rtt) && rtt >= 0) net.rttMs = rtt;
      }
      return;
    }
    if (msg.t === 'state') {
      net.prevTick = net.tick;
      net.tick = msg;
      predict.food = msg.food;
      if (msg.cps) {
        const newMs = 1000 / msg.cps;
        if (Math.abs(newMs - predict.tickMs) > 1) {
          predict.tickMs = newMs;
          // reset accumulator to reduce "shake" when speed changes
          predict.accMs = 0;
        }
      }
      predict.lastServerTick = msg.tick || predict.lastServerTick;

      // sync our authoritative state occasionally (hard correct if drift is too big)
      const me = msg.players.find(p => p.id === net.youId);
      if (me) {
        const serverSnake = (me.snake || []).map(s => ({x:s.x,y:s.y}));

        // If we have no local state, sync immediately.
        // NOTE: do NOT overwrite predict.dir on every packet; that causes "turn then snap back".
        if (!predict.snake || predict.snake.length === 0) {
          predict.snake = serverSnake;
          if (me.dir) predict.dir = me.dir;
          predict.accMs = 0;
        } else {
          // correct only when drift is obvious (prevents visible "shake")
          const lh = predict.snake[predict.snake.length-1];
          const sh = serverSnake[serverSnake.length-1];
          const drift = (!lh || !sh) ? 0 : (Math.abs(lh.x-sh.x) + Math.abs(lh.y-sh.y));
          if (drift >= 4 || predict.snake.length !== serverSnake.length) {
            predict.snake = serverSnake;
            // keep local predict.dir; server dir lags behind by network/tick
            predict.accMs = 0;
          }
        }
      }

      ensurePredictLoop();

      renderRoomLight(msg);
      // render quickly (override self with predicted)
      scene()?.renderState?.(msg, predict);
      updateHud(msg.players);
      return;
    }
    if (msg.t === 'death') {
      if (msg.id === net.youId) showToast('你死了，2秒后复活');
      return;
    }
  });

  // ===== Controls =====
  function setDir(dx,dy){
    // local immediate response
    if (!(dx === -predict.dir.x && dy === -predict.dir.y)) {
      predict.dir = {x:dx,y:dy};
    }
    // send immediately (server applies on next tick)
    send({ t:'input', dir:{x:dx,y:dy} });
  }

  // Capture direction keys even when an input is focused (prevents "can't turn" feeling)
  window.addEventListener('keydown', (e) => {
    const k = String(e.key || '').toLowerCase();
    const isDir = (k==='arrowup'||k==='arrowdown'||k==='arrowleft'||k==='arrowright'||k==='w'||k==='a'||k==='s'||k==='d');
    if (!isDir) return;

    // prevent page scroll/caret move
    e.preventDefault();

    if (k==='arrowup' || k==='w') setDir(0,-1);
    else if (k==='arrowdown' || k==='s') setDir(0,1);
    else if (k==='arrowleft' || k==='a') setDir(-1,0);
    else if (k==='arrowright' || k==='d') setDir(1,0);
  }, {passive:false, capture:true});

  // ===== UI actions =====
  btnCreate.addEventListener('click', () => send({ t:'create', name: inpName.value || '玩家', color: inpColor.value }));
  btnJoin.addEventListener('click', () => send({ t:'join', code: (inpCode.value||'').trim().toUpperCase(), name: inpName.value || '玩家', color: inpColor.value }));
  btnStart.addEventListener('click', () => send({ t:'start' }));

  function renderRoom(){
    if (!net.room) return;
    elRoomCode.textContent = net.room.code;
    elStatus.textContent = net.room.state === 'running' ? '进行中' : net.room.state === 'ended' ? '已结束' : '大厅';
    elTimeLeft.textContent = net.room.endsAt ? fmtMs(Math.max(0, net.room.endsAt - Date.now())) : '—';

    const ps = net.room.players || [];
    elPlayers.innerHTML = ps.map(p => {
      const th = themes[p.color] || themes.green;
      const dot = '#' + th.a.toString(16).padStart(6,'0');
      const alive = p.alive ? '' : '（复活中）';
      return `<div class="p"><div class="left"><span class="dot" style="background:${dot}"></span><div>${escapeHtml(p.name)} <span class="small">${alive}</span></div></div><div>${p.score}</div></div>`;
    }).join('');

    updateHud(ps);
  }

  function renderRoomLight(tick){
    elTimeLeft.textContent = tick.endsAt ? fmtMs(Math.max(0, tick.endsAt - Date.now())) : '—';
  }

  function updateHud(players){
    // latency: show measured RTT if available; fallback to "age" (time since last server packet)
    if (net.rttMs != null) {
      elLatency.textContent = `${Math.round(net.rttMs)}ms`;
    } else {
      const age = performance.now() - net.lastRecvAt;
      elLatency.textContent = isFinite(age) ? `${Math.round(age)}ms` : '—';
    }
  }

  function predictStepOnce(){
    if (!predict.snake || predict.snake.length === 0) return;

    const head = predict.snake[predict.snake.length - 1];
    const nx = head.x + predict.dir.x;
    const ny = head.y + predict.dir.y;

    // wall/self collision (local): don't "erase" the snake (looks like shaking/flicker).
    // Just stop advancing prediction and let server state correct us.
    if (nx < 0 || ny < 0 || nx >= GRID || ny >= GRID) return;

    const willEat = predict.food && nx === predict.food.x && ny === predict.food.y;
    const bodyToCheck = willEat ? predict.snake : predict.snake.slice(1);
    if (bodyToCheck.some(p => p.x === nx && p.y === ny)) return;

    predict.snake.push({x:nx,y:ny});
    if (!willEat) predict.snake.shift();
  }

  function ensurePredictLoop(){
    if (!predict.enabled) return;
    if (predict.rafId) return;

    predict.lastNow = performance.now();
    const loop = () => {
      predict.rafId = requestAnimationFrame(loop);

      // only simulate when round is running
      if (!net.room || net.room.state !== 'running') return;
      if (!predict.snake || predict.snake.length === 0) return;

      const now = performance.now();
      let dt = now - predict.lastNow;
      predict.lastNow = now;

      // cap dt to avoid huge jumps (tab switch)
      dt = Math.min(dt, predict.tickMs * 3);
      predict.accMs += dt;

      while (predict.accMs >= predict.tickMs) {
        predictStepOnce();
        predict.accMs -= predict.tickMs;
      }

      // render predicted self immediately
      if (net.tick) scene()?.renderState?.(net.tick, predict);
    };

    predict.rafId = requestAnimationFrame(loop);
  }

  // refresh timer
  setInterval(() => {
    if (net.room?.endsAt) elTimeLeft.textContent = fmtMs(Math.max(0, net.room.endsAt - Date.now()));
  }, 250);
})();
</script>
</body>
</html>
